'use strict';;let Has160,Md2,Md4,Md5,Ripemd,Sha0,Sha1,Sha256,Sha512,Snefru,Whirlpool,fromUtf,fromArrayBuffer,toHex,toBase64,Hmac;_34e‍.x([["default",()=>_34e‍.o]]);_34e‍.w("./hasher/has160",[["default",["Has160"],function(v){Has160=v}]]);_34e‍.w("./hasher/md2",[["default",["Md2"],function(v){Md2=v}]]);_34e‍.w("./hasher/md4",[["default",["Md4"],function(v){Md4=v}]]);_34e‍.w("./hasher/md5",[["default",["Md5"],function(v){Md5=v}]]);_34e‍.w("./hasher/ripemd",[["default",["Ripemd"],function(v){Ripemd=v}]]);_34e‍.w("./hasher/sha0",[["default",["Sha0"],function(v){Sha0=v}]]);_34e‍.w("./hasher/sha1",[["default",["Sha1"],function(v){Sha1=v}]]);_34e‍.w("./hasher/sha256",[["default",["Sha256"],function(v){Sha256=v}]]);_34e‍.w("./hasher/sha512",[["default",["Sha512"],function(v){Sha512=v}]]);_34e‍.w("./hasher/snefru",[["default",["Snefru"],function(v){Snefru=v}]]);_34e‍.w("./hasher/whirlpool",[["default",["Whirlpool"],function(v){Whirlpool=v}]]);_34e‍.w("./encoder/utf",[["fromUtf",["fromUtf"],function(v){fromUtf=v}]]);_34e‍.w("./encoder/array-buffer",[["fromArrayBuffer",["fromArrayBuffer"],function(v){fromArrayBuffer=v}]]);_34e‍.w("./encoder/hex",[["toHex",["toHex"],function(v){toHex=v}]]);_34e‍.w("./encoder/base64",[["toBase64",["toBase64"],function(v){toBase64=v}]]);_34e‍.w("./mac/hmac",[["default",["Hmac"],function(v){Hmac=v}]]);


















/**
 * Main class for ES5 compatibility.
 * Please use subclasses of {@link Hasher} for ES6
 */
class CryptoApi {
  /**
   * @ignore
   */
  constructor() {
    /** @type {{}} */
    this.encoder = {};
    /** @type {fromUtf} */
    this.encoder.fromUtf = fromUtf;
    /** @type {fromArrayBuffer} */
    this.encoder.fromArrayBuffer = fromArrayBuffer;
    /** @type {toHex} */
    this.encoder.toHex = toHex;
    /** @type {toBase64} */
    this.encoder.toBase64 = toBase64;
  }

  /**
   * Get hasher by alias
   *
   * @param {string} name
   * @param {Object} options
   * @returns {Hasher}
   */
  getHasher(name, options) {
    options = options || {};
    switch (name) {
      case 'has160':
        return new Has160(options);
      case 'md2':
        return new Md2(options);
      case 'md4':
        return new Md4(options);
      case 'md5':
        return new Md5(options);
      case 'ripemd128':
        options = Object.assign({}, {length: 128}, options);
        return new Ripemd(options);
      case 'ripemd':
      case 'ripemd160':
        options = Object.assign({}, {length: 160}, options);
        return new Ripemd(options);
      case 'ripemd256':
        options = Object.assign({}, {length: 256}, options);
        return new Ripemd(options);
      case 'ripemd320':
        options = Object.assign({}, {length: 320}, options);
        return new Ripemd(options);
      case 'sha0':
        return new Sha0(options);
      case 'sha1':
        return new Sha1(options);
      case 'sha224':
        options = Object.assign({}, {length: 224}, options);
        return new Sha256(options);
      case 'sha256':
        options = Object.assign({}, {length: 256}, options);
        return new Sha256(options);
      case 'sha384':
        options = Object.assign({}, {length: 384}, options);
        return new Sha512(options);
      case 'sha512':
        options = Object.assign({}, {length: 512}, options);
        return new Sha512(options);
      case 'sha512/224':
        options = Object.assign({}, {length: 224}, options);
        return new Sha512(options);
      case 'sha512/256':
        options = Object.assign({}, {length: 256}, options);
        return new Sha512(options);
      case 'snefru':
      case 'snefru128':
      case 'snefru128/8':
        options = Object.assign({}, {length: 128}, options);
        return new Snefru(options);
      case 'snefru256':
      case 'snefru256/8':
        options = Object.assign({}, {length: 256}, options);
        return new Snefru(options);
      case 'snefru128/2':
        options = Object.assign({}, {length: 128, rounds: 2}, options);
        return new Snefru(options);
      case 'snefru256/4':
        options = Object.assign({}, {length: 256, rounds: 4}, options);
        return new Snefru(options);
      case 'whirlpool':
        return new Whirlpool(options);
      case 'whirlpool-0':
        options = Object.assign({}, {type: '0'}, options);
        return new Whirlpool(options);
      case 'whirlpool-t':
        options = Object.assign({}, {type: 't'}, options);
        return new Whirlpool(options);
    }
  }

  /**
   * Hash UTF message and return result in hex
   *
   * @param {string} name
   * @param {string} message
   * @param {Object} options
   * @returns {string}
   */
  hash(name, message, options) {
    options = options || {};
    let hasher = this.getHasher(name, options);
    hasher.update(fromUtf(message));
    return toHex(hasher.finalize());
  }

  /**
   * Get HMAC instance
   *
   * @param {string} key
   * @param {Hasher} hasher
   * @returns {Hmac}
   */
  getHmac(key, hasher) {
    return new Hmac(key, hasher);
  }

  /**
   * HMAC with UTF key from UTF message and return result in hex
   *
   * @param {string} key
   * @param {string} message
   * @param {Hasher} hasher
   * @returns {string}
   */
  hmac(key, message, hasher) {
    let mac = this.getHmac(fromUtf(key), hasher);
    mac.update(fromUtf(message));
    return toHex(mac.finalize());
  }
}

CryptoApi = new CryptoApi();
_34e‍.d(CryptoApi);